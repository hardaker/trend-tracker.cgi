#!/usr/bin/perl

use DBI;
use strict;
use Carp;
use IO::File;
use Data::Dumper;

my %opts = ('d' => 'trend-tracker.sqlite',
	    'c' => 'trend-tracker.config',
	    'D' => 'DBI:SQLite:dbname=');
my %config;

my @reportlist = qw(total_response_count
                    number_of_submitter_addresses
                    number_of_resolvers
                    table_numerical_breakdown_by_server
                    table_numerical_breakdown_by_submission_address
                   );
#                    detailed_numerical_breakdown_by_server
#                    detailed_numerical_breakdown_by_submission_address
#                    table_percentage_breakdown_by_server
#                    table_percentage_breakdown_by_submission_address

my %reportGenerators =
    (
     total_response_count =>                    \&total_response_count,
     number_of_submitter_addresses => 		\&number_of_submitter_addresses,
     number_of_resolvers =>           		\&number_of_resolvers,
     detailed_numerical_breakdown_by_server => 
                \&detailed_numerical_breakdown_by_server,
     detailed_numerical_breakdown_by_submission_address =>
                \&detailed_numerical_breakdown_by_submission_address,
     table_numerical_breakdown_by_server =>
                \&table_numerical_breakdown_by_server,
     table_numerical_breakdown_by_submission_address =>
                \&table_numerical_breakdown_by_submission_address,
     table_percentage_breakdown_by_server =>
                \&table_percentage_breakdown_by_server,
     table_percentage_breakdown_by_submission_address =>
                \&table_percentage_breakdown_by_submission_address,
    );

LocalGetOptions(\%opts,
	   ['GUI:VERSION',     "trend-tracker version: 0.7"],
	   ["c|config-file=s", "Config file to read"],
	   ['t|table=s',       'Database table name'],
          ) || die;

read_config($opts{'c'});

# pull out the various data keys
my $key         = $config{'key'};
my $parameters  = config_array('parameters');
my $extras      = config_array('extras');

my $table       = $opts{'t'} || $config{'table'} || "data" ; 

# actually perform the connection and creation
my $dbh = DBI->connect($config{'database'},
		       $config{'dbuser'}, $config{'dbpassword'});

#######################################################################
# Report handling
#
maybePrintFileFromToken('analysisStart');

if (exists($config{'analysisReports'})) {
    @reportlist = @{config_array('analysisReports')};
}

foreach my $reportName (@reportlist) {
    if (!exists($reportGenerators{$reportName}) || 
	ref($reportGenerators{$reportName}) ne 'CODE') {
	print STDERR "*** failure: report $reportName had no generator.  Typo?\n";
	exit;
    }
    $reportGenerators{$reportName}->();
}

maybePrintFileFromToken('analysisEnd');

######################################################################
# Report generators
#
sub total_response_count {
    my (@args) = @_;
    my $count = get_total_entry_count();
    print "<ul id=\"total_response_count\" class=\"trend-tracker-ul\"><li>Number of entries submitted: $count</li></ul>\n";
}

sub number_of_submitter_addresses {
    my (@args) = @_;
    my $remoteaddresscount = get_total_remoteaddress();
    print "<ul id=\"number_of_submitter_addresses\" class=\"trend-tracker-ul\"><li>Number of submitting addresses: " . $remoteaddresscount . "</li></ul>\n";
}

sub number_of_resolvers {
    my (@args) = @_;
    my $servercount = get_total_server_count();
    print "<ul id=\"number_of_resolvers\" class=\"trend-tracker-ul\"><li>Number of servers: " . $servercount . "</li></ul>\n";
}

sub table_percentage_breakdown_by_server {
    table_numerical_breakdown_by_server(@_, 'percent_only' => 1);
}

sub table_percentage_breakdown_by_submission_address {
    table_numerical_breakdown_by_submission_address(@_, 'percent_only' => 1);
}

sub table_numerical_breakdown_by_server {
    my (@args) = @_;
    table_numerical_breakdown_by("Server", "server",
				 get_total_server_count(), @args);
}

sub table_numerical_breakdown_by_submission_address {
    my (@args) = @_;
    table_numerical_breakdown_by("Submission Address", "remoteaddress",
				  get_total_remoteaddress(), @args);
}

sub table_numerical_breakdown_by {
    my ($name, $colname, $totalcount, %args) = @_;
    my @parameters = @{config_array('parameters')};

    print "<h2 class=\"trend-tracker-header\">Answer Percentages by $name</h2>";

    my %completeData;

    print "<table id=\"trend-tracker-table-$name\" class=\"trend-tracker-table\">\n";
    print "  <tr><th>&nbsp;</th>";

    my $colspan = "colspan=\"2\"" if (!$args{'percent_only'});

    foreach my $parameter (@parameters) {
	print "<th $colspan class=\"trend-tracker-top-header trend-tracker-header\">$parameter</th>";
	my $data = $dbh->selectall_arrayref(
	    "select $parameter,count($parameter)
               from (select $parameter, $colname, count($colname)
                       from $table as t1
                      group by $colname,$parameter) as t2
             group by $parameter
             order by $parameter");
	foreach my $valuerow (@$data) {
	    $completeData{$valuerow->[0]}{$parameter} = $valuerow->[1];
	}
    }
    print "  </tr>\n";

    foreach my $value (keys(%completeData)) {
	print "  <tr><th class=\"trend-tracker-header trend-tracker-left-header\">" . valueMap("----", $value) . "</th>\n";
	foreach my $parameter (@parameters) {
	    my $yesNoMaybeClass = 
		$completeData{$value}{$parameter} == 0 ?
		"trend-tracker-data-0" :
		     ($completeData{$value}{$parameter} == $totalcount ?
                      "trend-tracker-data-100" :
		      "trend-tracker-data-inbetween");
	    $yesNoMaybeClass .= " " . $yesNoMaybeClass . "-" 
		. valueMap("----",$value);

	    # print the percentage column
	    if (!$args{'percent_only'}) {
		print "<td class=\"trend-tracker-column trend-tracker-raw-number-column $yesNoMaybeClass\">" . ($completeData{$value}{$parameter} || "0") . "</td>";
	    }

	    # print the row data column
	    print "<td class=\"trend-tracker-column trend-tracker-percentage-column $yesNoMaybeClass\">" .
		percent($completeData{$value}{$parameter}, $totalcount) .
		"</td>";
	}
	print "</tr>\n";
    }
    print "</table>\n";
}


sub detailed_percentage_breakdown_by_server {
    my (@args) = @_;
    my @parameters = @{config_array('parameters')};

    print "<h2 class=\"trend-tracker-header\">Answer Percentages by Server</h2>";

    my $servers = get_total_server_count();

    foreach my $parameter (@parameters) {
	my $data = $dbh->selectall_arrayref(
	    "select $parameter,count($parameter)
               from (select $parameter, server, count(server)
                       from $table
                      group by server,$parameter)
             group by $parameter
             order by $parameter");
	print "<h3 class=\"trand-tracker-subheader\">$parameter</h3>\n";
	print "<table class=\"trend-tracker-table\">\n";
	foreach my $row (@$data) {
	    my $value = shift @$row;
	    printRow(valueMap($parameter, $value), @$row,
		     percent($row->[0], $servers));
	}
	print "</table>\n";
    }
}

sub detailed_percentage_breakdown_by_submission_address {
    my (@args) = @_;
    my @parameters = @{config_array('parameters')};

    print "<h2 class=\"trend-tracker-header\">Answer Percentages by Submission Address</h2>";

    my $addresses = get_total_remoteaddress();

    foreach my $parameter (@parameters) {
	my $data = $dbh->selectall_arrayref(
	    "select $parameter,count($parameter)
               from (select $parameter, remoteaddress, count(remoteaddress)
                       from $table
                      group by remoteaddress,$parameter)
             group by $parameter
             order by $parameter");
	print "<h3 class=\"trand-tracker-subheader\">$parameter</h3>\n";
	print "<table class=\"trend-tracker-table\">\n";
	foreach my $row (@$data) {
	    my $value = shift @$row;
	    printRow(valueMap($parameter, $value), @$row,
		     100 * $row->[0] / $addresses);
	}
	print "</table>\n";
    }
}

my $total_count = "";
sub get_total_entry_count {
    
    return $total_count if ($total_count ne "");
    my $data = $dbh->selectall_arrayref("select count(*) from $table");
    $total_count = $data->[0][0];
    return $total_count;
}

my $total_servers = "";
sub get_total_server_count {
    return $total_servers if ($total_servers ne "");
    my $data = $dbh->selectall_arrayref("select count(distinct(server)) from $table");
    $total_servers = $data->[0][0];
    return $total_servers;
}

my $total_remoteaddress = "";
sub get_total_remoteaddress {
    return $total_remoteaddress if ($total_remoteaddress ne "");
    my $data = $dbh->selectall_arrayref("select count(distinct(remoteaddress)) from $table");
    $total_remoteaddress = $data->[0][0];
    return $total_remoteaddress;
}

######################################################################
# Utility Functions
#
sub printRow {
    my (@rowData) = @_;
    print "<tr><td>" . join("</td><td>", @rowData) . "</td></tr>\n";
}

sub valueMap {
    my ($name, $value) = @_;
    if (exists($config{"value." . $name . "." . $value})) {
	return $config{"value." . $name . "." . $value};
    }
    if (exists($config{"value." . $value})) {
	return $config{"value." . $value};
    }
    return $value;
}

sub maybePrintFileFromToken {
    my ($filetoken) = @_;
    if ($config{$filetoken}) {
	my $tnh = new IO::File;
	my $buffer;
	$tnh->open($config{$filetoken});
	while(read($tnh, $buffer, 4096) > 0) {
	    print $buffer;
	}
    }
}

sub percent {
    my ($top, $bottom) = @_;
    return sprintf("%02.2f%%", $top * 100 / $bottom);
}

sub Error {
    print STDERR "Fatal Error: ", join(" ", @_);
    exit 1;
}

#######################################################################
# general routines
#
#### WARNING: Must Match Copy in createdb/trend-tracker.cgi
#             (to keep this file self-contained, we duplicate it here)
sub read_config {
    my ($file) = @_;
    my $fh = new IO::File;
    if (! -f $file || !$fh->open($file)) {
	Error("failed to open the config file: $file");
    }

    while(<$fh>) {
	next if (/^\s*#/);
	next if (/^\s*$/);
	Error ("Illegal configuration directive: $_") if (! /:/);
	
	my ($key, $value) = /^\s*([^:]+):\s*(.*)/;
	if ($key eq 'include') {
	    read_config($value);
	} else {
	    $config{$key} = $value;
	}
    }
}

# splits a config token into separate pieces; Default separation is by comma
sub config_array {
    my ($token, $separator) = @_;

    return []          if (!exists($config{$token}));
    $separator = ","   if (!defined($separator));

    my @results = split(/$separator\s*/, $config{$token});
    return \@results;
}

######################################################################
# getopt::gui::long wrapper
#
sub LocalGetOptions {
    if (eval {require Getopt::GUI::Long;}) {
	import Getopt::GUI::Long;
	# optional configure call
	Getopt::GUI::Long::Configure(qw(display_help no_ignore_case capture_output no_gui));
	return GetOptions(@_);
    }
    require Getopt::Long;
    import Getopt::Long;
    # optional configure call
    Getopt::Long::Configure(qw(auto_help no_ignore_case));
    GetOptions(LocalOptionsMap(@_));
}

sub LocalOptionsMap {
    my ($st, $cb, @opts) = ((ref($_[0]) eq 'HASH')
			    ? (1, 1, $_[0]) : (0, 2));
    for (my $i = $st; $i <= $#_; $i += $cb) {
	if ($_[$i]) {
	    next if (ref($_[$i]) eq 'ARRAY' && $_[$i][0] =~ /^GUI:/);
	    push @opts, ((ref($_[$i]) eq 'ARRAY') ? $_[$i][0] : $_[$i]);
	    push @opts, $_[$i+1] if ($cb == 2);
	}
    }
    return @opts;
}

=pod

=head1 NAME

trend-analysis -- analyize the results collected by trend-tracker.cgi

=head1 SYNOPSIS

 # trend-analysis -c trend-tracker.config

=head1 DESCRIPTION

The B<trend-analysis> is used to look at the database filled by the
trend-tracker.cgi script and format results from it.

XXX: Currently this script does nothing but will in the future

=head1 OPTIONS

=over

=item  -c STRING



=item  --config-file=STRING

Config file to read

=item  -t STRING



=item  --table=STRING

Database table name

=back


=head1 SEE ALSO

trend-tracker.cgi(1), createdb(1)

=head1 AUTHOR

Wes Hardaker E<lt>opensource AT hardakers DOT netE<gt>

=head1 COPYRIGHT and LICENSE

Copyright (c) 2012 Wes Hardaker

All rights reserved.  This program is free software; you may
redistribute it and/or modify it under the same terms as Perl itself.
